exit
continue
exit
list_item.task
puts #{list_item_i + 1}. " + "hello"
puts (#{list_item_i + 1}. ") + "hello"
puts ((#{list_item_i + 1}. ") + "hello") 
list_item_i
list_item
list_array
exit
continue
task
next
task
next
task
exit
 /^\[ \]/ =~ tasks || /^\[X\]/ =~ tasks
tasks
task
testing
 /^\[ \]/ =~ testing || /^\[X\]/ =~ testing
task
/^\[ \]/ =~ task || /^\[X\]/ =~ task
0 || nil
0 == nil
/^\[ \]/ =~ task
task
/^\[X\]/ =~ task
task = "[ ]" + task
task
/^\[X\]/) =~ task.nil?
next
continue
task
next
task
next
task
exit
next
continue
exit
continue
tasks
task
list_array
@lists
@list
list
next
continue
next
continue
exit
xit
((/^\[X\]/) =~ "Move with Lil to the black mountain hills of Dakota").nil?
("Move with Lil to the black mountain hills of Dakota").nil?
(/^\[X\]/) =~ "Move with Lil to the black mountain hills of Dakota"
((/^\[X\]/) =~ task.first)
((/^\[X\]/) =~ task.first).nil?
hello.nil?
tasks.first
tasks
task
nil == nil
nil == 0
(/^\[X\]/) =~ "[0]hello"
(/^\[X\]/) =~ "[X]hello"
(/^\[X\]/) =~ "[X]"
"[X]hello" ~= (/^\[X\]/)
String.methods.sort
string.methods?.sort
string.methods?sort
string.methods.sort
string.method.sort
"[X]hello".match?(/^\[X\]/)
"[X]hello".contains?(/^\[X\]/)
"[X]hello".includes?(/^\[X\]/)
"[X]hello".has?(/^\[X\]/)
nil == nil
false == true
nil == true
nil == false
"[X]hello".include?(/^\[X\]/)
"[X]hello".include? /^\[X\]/
tasks.first
if (/^\[X\]/.match("[X]hello") || nil)
/^\[X\]/.match("[X]hello") || nil
nil || nil
/^\[X\]/.match("[X]hello")
/^\[ \]/.match("[X]hello")
/^\[ \]/.match("[ ]hello")
/^\[ \]/.match(tasks.first)
/^\[X\]/.match(tasks.first)
(^\[X\]).match(tasks.first)
tasks.first
tasks.list
tasks[0]
tasks.tasks
tasks.task
tasks.length
tasks
tasks[0]
tasks
continue
next
exit
@list.list[get_task].task
@list.list[get_task]
@list[get_task]
@list
get_task
@get_task
next
@list
next
exit
next
continue
next
args
option
exit
continue
exit
@list
@list.task
@list.list
output_file.close
output_file.puts(@list.list)
 output_file = File.new("test_file.csv","w+")
@list.complete(1)
@list
@lists
output_file.close
output_file.puts(@list.list)
 output_file = File.new("test_file.csv","w+")
@list.delete(1)
@list.delete(0)
@list.delete(10)
@list
output_file.close
output_file.puts(@list.list)
output_file = File.new("test_file.csv","w+")
output_file
output_file.puts(@list.list)
write(@list.list)
output_file.write(@list.list)
output_file = File.new("test_file.csv","w+")
output_file.write(@list.list)
output_file.puts(@list.list)
output_file = File.new("test_file.csv","w+")
output_file.puts(@list.list)
puts @list.list
@list.list.tasks.task
output_file.puts(@list.list.tasks)
output_file = File.new("test_file.csv","w+")
File.open("test_file.csv", "w+") do |f| (@list.list.each {|tasks| f.write(tasks.task)}) end
File.open("test_file.csv", "w+") do |f| (@list.list.each {|tasks| f.write(tasks.task newline)}) end
File.open("test_file.csv", "w+") do |f| (@list.list.each {|tasks| f.write(tasks.task)}) end
File.open("test_file.csv", "w+") do |f| (@list.list.each {|tasks| f.write(tasks.task + "/n")}) end
File.open("test_file.csv", "w+") do |f| (@list.list.each {|tasks| f.write(tasks.task + /n)}) end
File.open("test_file.csv", "w+") do |f| (@list.list.each {|tasks| f.write(tasks.task)}) end
File.open("test_file.csv", "w+") do |f| f.write(puts @list.list) end
@list.list.class
@list.list
@lists.list
File.open("test_file.csv", "w+") do |f| f.write(@list.list.puts) end
File.open("test_file.csv", "w+") do |f| f.write(@list.puts) end
File.open("test_file.csv", "w+") do |f| f.write(@list.list) end
File.open("test_file.csv", "w+") do |f| f.write(@list.list.each|tasks| task) end
File.open("test_file.csv", "w+") do |f| f.write(@list.list) end
@list
File.open("test_file.csv", "w+") do |f| f.write("hello again") end
File.open("test_file.csv", "w+") do |f| f.write("hi") end
@list.list.each{|tasks| p tasks}
@list.list.class
@list.list
@list.class
@list
@list.each {|tasks| p tasks}
@list.each{|tasks| p tasks}
@list
exit
@list
continue
next
exit
puts @list
@list.puts
@list.add(task)
puts @list
@list
task
option
exit
continue
next
@list
exit
options.empty?
options.nil?
options
@list
exit
options
@list
exit
@list
next
task
option
exit
Controller.new {option: "list", task: ""}
ARGV
option
exit
generate
require 'csv'
lists.generate
lists
todo.csv
file
lists
lists[3]
lists
lists.class
lists.methods.sort
lists.methods
lists
lists.add("Walk the dog")
add("Walk the dog")
add "Walk the dog"
puts lists
lists
lists = build_list
option
next
list
next
list
;ost
next
list
exit
!!!
option
optioni
task
option
continue
puts "Appeneded \"WAlk to this"
"Appeneded \"WAlk to this"
"Appeneded \"WAlk\" to this"
